//Конструктор по умолчанию есть такой метод, который может создать объект без передачи параметров(возможна передача)
//то, что после : есть инициализация, а внутри скобок присваивание
//по умолчанию у класса все поля приватные, а у структуры публичные
//У класса на самом деле 3 конструктора
//Конструктор преобразования позволяет манипулировать передачей разных других типов данных(explicit запрещает это делать класс Complex)
//Не стоит инициализировать один объект класса другим, если в классе выделяется память под какой-то параметр, так как при окончании программы дважды освободится память
//Конструктор копирования делает побитовый дубликат объекта(когда происходит передача в функции копии объекта)
//Не стоит передавать копию объекта, который был динамически выделен, потому что память будет освобождаться дважды
//следует явно прописать конструктор копирования, либо же использовать ссылку на объект
//следует при работе с функциями, которые возвращают объекты классов, учесть тот факт, освобождает ли деструктор динамическую память, так как по окончании 
//функции объект уничтожится и деструктор освободит память и в ячейку передается пустой объект, то есть будет дважды освобождаться память в итоге
//Пользовательские конструкторы замещают конструкторы по умолчанию
//Прописывание конструкторов в приватной зоне(позволяет методам использовать, но за пределами нет) или инициализация им delete приведёт к уничтожению конструкторов
//Лучше всего прописывать прототипы методов и классов в .h файлах, а реализацию и функцию main отдельно друг от друга, ради лучшей навигации
//Операция присваивания может использоваться для переменных одинакового типа данных(можно перегрузить оператор и сделать иначе)
//Есть 2 способа инициализации массива объектов класса(обычная, если конструктор имеет 1 параметр и полная - обычное определение объектов с передачей 2 и более параметров)
//статические поля классов нужно инициализировать в глобальной области, эти поля доступны на уровне класса, а не объекта, то есть поле общее для всех объектов
//статические методы доступны для всех объектов и для класса, они общие
//Паттерн синглтон нужен для существования 1 объекта, а другие переменные этого класса в main будут лишь ссылаться на одну и ту же область памяти
//нельзя использовать не const методы в других const методах, в const методах предполагается неизменчивость, а чтобы создать переменную, которая обходила это, то нужно указать mutable
//Стоит отложить использование friend функций и классов
//Правило трёх и пяти - если определяется конструктор копирования, то должен быть и деструктор, и операция присваивания, но при C++14 Ещё добавляются 
//конструктор перемещения и конструктор копирования перемещением
//Если перегружать оператор инкремента или декремента, то для перфиксной формы параметры не передаются, а для постфиксной форма передаётся int
//Так же есть возможность переопределять операцию () - функторы, (double operator()(){}). 
//Можно задавать && выражения к типу данных для того, чтобы бороться правильно с адресацией и ячейками памяти(используется в конструкторах перемещения)
//Правило пяти - если определяетс конструктор перемещением, то следует определить конструктор по умолчанию, копирования и операторы присваивания копированием и присваивание перемещением
//Компилятор сам раставляет приоритеты и если есть конструктор перемещением и присваиванием перемещением, то это будет предпочтительнее
//присваивание перемещением - данные как бы забираются с правого выражения к левому
//Protected позволяет дать доступ к данным в рамках этой области к другим дочерним классам, стоит относиться к этой зоне как к public, так как все дочерние классыы имеют прямой доступ к переменным
//объекты, имеющие несколько имен, свидетельствуют о плохой организации программы.
//вызов методов базового класса в дочернем классе - полиморфизм адресов
//Наследование private будет ограничивать все публичные поля базового класса, для объектов дочернего класса(protected не используется = private)
//Можно переопределять переменные, функции и прочее. Поиск идёт сначало от дочернего класса к базовому классу
//Вызываются сначала конструктор базового класса, а после дочернего. Если базовый класс требует параметры, то в дочернем должен быть предусмотрен конструктор, который вызывает конструктор базового класса
//vitrual динамический полиморфизм
//override прямо указывает компилятору, что данная функция будет виртуальной(стоит прописывать всегда)
//final означает, что нельзя переопределять виртуальный метод в дочерних классах
//virtual деструкторы стоит объявлять всегда, когда используется наследование или же виртуальные методы, иначе риск не вызвать деструктор дочерних классов
//Для создания динамического массива объектов класса следует предусмотреть 2 конструктора инициализации нулями и значениями
//В языке C++ можно перегружать операторы n e w и d e l e t e . Это приходится делать, если возникает необходимость создать особый механизм распределения памяти.Например, можно потребовать, чтобы процедура распределения памяти использовалажесткий диск в качестве виртуальной памяти, если куча исчерпана. Перегрузка операторов n e w и d e l e t e осуществляется очень просто
//На перегрузку этих операторов распространяется одно общее ограничение: онидолжны быть нестатическими функциями-членами. Дружественные функцииприменять нельзя.() [] -> ,
//Можно обходить private наследование - в публичной области базовый_класс::член(нельзя так делать, лучше использовать аналог с using)
//Может происходить такая ситуация, что 2 дочерних класса будут создавать новый дочерний класс, тогда будет 2 копии базового класса - неоднохначность
//| проблема решается областью видимости или же виртуальным наследованием class n : virtual public m
//Чисто виртуальные функции должны переопределяться в каждом производном классе, в противном случае возникнет ошибка компиляции. virtual type name() = 0;
//Нельзя создавать объекты абстрактных классов(где есть чисто виртуальные функции)
//Виртуальные функции - пример позднего связывания, то есть программа принимает решения в ходе выполнения программы - обеспечивает гибкость, но замедляет работу
//Раннее связывание - пример - обычная функция - событие, происходящее на этапе компиляции программы(Программа уже знает о типах) - увеличивается скорость, понижается гибкость
//Обобщенная функция объявляется с помощью ключевого слова template 
//Следует использовать явную специализацию для обработки искючений шаблонной функции
//Смешение обобщенных и стандартных параметров не вызывает никаких проблем и может оказаться полезным
//Если логика функции не зависит от типа данных, ее можно преобразовать в шаблонную.
//В качестве стандартных параметров допускаются целые числа, указатели и ссылки(все стандартные параметры - константные)
//Можно использовать аргументы по умолчанию class X = int
//Если поместить конструктор базового класса в protected, то нельзя будет создавать объекты этого класса вне это класса
//Если поместить деструктор дочернего класса в protected, то мы не сможем создавать объекты, помещённые в стек, а только в кучу(Их можно создавать при помощи new, а следует выделять память при помощи статического метода, который будет этим заниматься)
//Следует избегать ромбовидного наследовани, так как возможно получить неопределённость, но это решается при помощи виртуального наследования
//Разбор принципов исключительных ситуаций - try - код подлежащий контролю, исключительные ситуации перехватываются блоков catch, а throw генерирует указаную исключительную ситуацию
//Если нет исключительной ситуации, то catch будет проигнорировано
//Если в обработке исключительных ситуаций участвует объект дочернего класса, то следует проверять по catch начиная с производных классов до базовых, а не наоборот
//catch(...){}//обработка всех ситуаций
//исключительный механизм типов исключений устарел и не используется вообще
//terminate(), unexpected() - функции вызываются в крайнем случае, когда обработка исключений неверная <exception>
//terminate() вызывает abort()
//unexpected() вызывается при попытке генерировать ситуацию, не указанную в throw
//Чтобы изменить обработчик, связанный с функцией te r m in a te O , следует вызватьфункцию set_terminate(), как показано ниже
//terminate_handler set_terminate(terminate_handler newhandler) throw();

#include <iostream>
#include <fstream>

class Test1{
private:
	int lenght{0};
	int* data{nullptr};

public:
	Test1(int size) : lenght(size) { data = new int[lenght]; }
	Test1(const Test1& other) : Test1(other.lenght) { data = new int[lenght]; for(int i = 0; i < lenght; i++) data[i] = other.data[i]; }
	Test1(Test1&& move) noexcept : lenght(move.lenght) { data = move.data; move.data = nullptr; } // конструктор перемещением
	~Test1(){ delete[] data; }
	const Test1& operator =(const Test1& right)
	{
		if(this == &right) return *this;
		lenght = right.lenght;
		delete[] data;
		data = new int[lenght];
		for(int i = 0; i < lenght; i++) data[i] = right.data[i];
		return *this;
	}
	Test1& operator =(Test1&& move)
	{
		if(this == &move) return *this;
		lenght = move.lenght;
		data = move.data;
		move.data = nullptr;
		return *this;
	}//присваивание перемещением
};

class Point
{
	int x{0}, y{0};

public:
	mutable int count_call {0};//не рекомендуемая практика, так как может привести к непредвиденным обстоятельствам

	Point(int a, int b) : x(a), y(b) {}

	void set_coords(const Point& p)
	{
		count_call++;
		x = p.x; y = p.y;
		p.get_coords(x, y);
	}

	void get_coords(int &a, int &b) const { count_call++; a = get_x(); b = get_y(); }

	int get_x() const {count_call++; return x;}
	int get_y() const {count_call++; return y;}
};

class Singleton
{
private:
	int data{0};
	static Singleton* instance;
	Singleton() = default;

public:
	Singleton(const Singleton& ) = delete;
	~Singleton(){ instance = nullptr; }

	static Singleton* get_instance()
	{
		if(instance == nullptr) instance = new Singleton;
		return instance;
	}

	void set_data(int i){ data = i; }
	int get_data(){ return data; }
};

Singleton* Singleton::instance = nullptr;

class Complex
{
private:
	double im, re;

public:
	Complex() : im(0.0), re(0.0){}
	//explicit Complex(double r) : im(0.0), re(r){}
	Complex(double r) : im(0.0), re(r){}
	Complex(double r, double i) : im(i), re(r){}

	void set_complex(double i, double r){ im = i; re = r; }
	void get_complex(double& i, double& r){i = im; r = re; }
};

class Point2D
{
private:
//Возможна так же инициализация полей в самом классе
	static unsigned counter;
	int x, y;
	unsigned int max_coord;

public:
	Point2D(int a = 0, int b = 0) : max_coord(100), x(a), y(b) { counter++; } //Конструктор по умолчанию

	void set_coords(int a, int b){ x = a; y = b; } // пример inline function
	void get_coords(int& a, int& b){ a = x; b = y; }

	~Point2D(){}
};

unsigned Point2D::counter = 0; //Инициализация статической переменной 
//использовался для подсчета количества объектов класса

class Point3D
{
private:
	int total;
	int *coords{nullptr};

public:
	Point3D(int t = 1) : total(t) {coords = new int[total]{0};}
	Point3D(int t, int* cz) : Point3D(t) {set_coords(cz, t);} //Делигирующий конструктор
	Point3D(const Point3D& other) : Point3D(other.total, other.coords) {} //Делигирующий конструктор копирования 

	void set_coords(int* arr, int len)
	{
		for(int i = 0; i < total; i++) coords[i] = (i < len) ? arr[i] : 0;
	}

	int* get_coords(){ return coords; }

	const Point3D& operator=(const Point3D other) //переопределение оператора равно так как конструктор копирования срабатывает при инициализации
	{
		delete[] coords;
		total = other.total;
		coords = new int[total];
		set_coords(other.coords, total);
	}
};

Test1 create_ar(int size) { Test1 obj(size); return obj; }//Будет здесь использоваться конструктор перемещением

template<class X> void swapargs(X &a, X &b) { X temp = a; a = b; b = temp; } //Обобщённая функция = шаблонная функция(специализация)
template<> void swapargs(int &a, int &b) { int temp = a; a = b; b = temp; } //явная специализация

//явная специализация класса
template<class T> class myclass{
	T x;
public: 
	myclass(T a) : x(a) {}
	T getx() { return x; }
};
template<> class myclass<int>{
	int x;
public:
	myclass(int a) : x(a) {}
	int getx() { return x; }
};
 

//Пример перегрузки шаблонной функции
template<class X> void printarg(X &a) { std::cout << a << std::endl; }
template<class X, class Y> void printarg(X &a, Y &b) { std::cout << a << b << std::endl; }

//Пример шаблонного класса
template<class StackType> class stack{
	StackType stck[10];
	int tos;
public:
	stack() : tos(0) {}
	void push(StackType &ob);
	StackType pop();
};

template<class StackType> void stack<StackType>::push(StackType &ob) { if(tos == 10) return; stck[tos++] = ob; }
template<class StackType> StackType stack<StackType>::pop() { return tos == 0 ? 0 : stck[tos--]; }

//Пример ромбовидного наследовани
class General{
protected:
	General(){ std::cout << "general constructor" << std::endl; }//запрещает создавать вне класса объекты
	size_t get_size_obj() const { return sizeof(*this); }
};
class GeomBase : virtual public General{
protected:
	int x0{0}, y0{0}, x1{0}, y1{0};
public:
	GeomBase(int x0 = 0, int y0 = 0, int x1 = 0, int y1 = 0) : x0(x0), x1(x1), y0(y0), y1(y1) { std::cout << "geombase constructor" << std::endl; }
	virtual ~GeomBase() { std::cout << "geombase destructor" << std::endl; }
	void set_coords(int x0, int y0, int x1, int y1) { this->x0 = x0; this->y0 = y0; this->x1 = x1; this->y1 = y1; }
	virtual void draw() const = 0;//чисто виртуальный метод, блокирует создание объекта этого класса на прямую, является абстрактным классом
};
class GeomRealise : virtual public General{
protected:
	bool fl_saved {false};
public:
	GeomRealise() { std::cout << "geomrealise constructor" << std::endl; }
	virtual ~GeomRealise() { std::cout << "geomrealise destructor" << std::endl; }
	virtual void save(std::ofstream& os) const = 0;
	virtual void load(std::ifstream& is) = 0;
};
class Line : public GeomBase, public GeomRealise{
private:
	double length{0.0};
protected:
	virtual ~Line() { std::cout << "line destructor" << std::endl; }//запрещает создавать объекты в стеке
public:
	Line(int a = 0, int b = 0, int c = 0, int d = 0) : GeomBase(a, b, c, d) { std::cout << "line constructor" << std::endl; }
	virtual void draw() const override { printf("Line: %d, %d, %d, %d\n", x0, y0, x1, y1); }
	virtual void save(std::ofstream& os) const override { os.write((char*)this, sizeof(*this)); }
	virtual void load(std::ifstream& is) override { is.read((char*)this, sizeof(*this)); }
	static void delete_object(Line* obj) { delete obj; }
};

int main(void)
{
	std::cout.width(5);//задает длину выводимого сообщения, остатки заполняет заменителем(пробел)
	std::cout.precision(1);//задает число чисел после точки, остатки заполняет заменителем(пробел)
	std::cout.fill('-');//изменяет заменитель

	std::cout << 2.0/3.0;
	// Line* obj1 = new Line(1, 2, 10, 20);
	// Line::delete_object(obj1);

	// int a = 10, b = 16;
	// double x = 13.5, y = 15.4;

	// swapargs(a, b);
	// swapargs(x, y);

	// Complex num1 = 5.0;//Класс использует вещественное число и преобразует его в комплексное
	// Complex num2;
	// Complex num3 = {5.0, 6.0};

	// Point3D pt(5);
	// Point3D pt2;

	// pt2 = pt;//можно переопределить равно и убрать недостатки при работе с памятью

	// int* arr = pt2.get_coords();
	// for(int i = 0; i < 5; i++) std::cout << arr[i] << " ";

	// Singleton* ptr = Singleton::get_instance();//создаёт первый объект класса, если его ещё нет
	// Singleton* ptr2 = Singleton::get_instance();//будет иметь ту же область памяти, что и ptr

	// ptr->set_data(1);

	// std::cout << ptr->get_data() << " " << ptr2->get_data() << std::endl;

	// //int& lnk_ptr = Point3D(); в данной строке мы пытаемся инициализовароть ячейку памяти временными данными, что недопустимо
	// const Test1& lnk_ptr = Test1();//так можно делать, так как конст определяет постоянность, но не позволяет изменять значение
	// Test1&& lnk_pt = Test1();//Позволяет изменять значение
}
